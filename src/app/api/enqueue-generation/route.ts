import { NextRequest, NextResponse } from "next/server";

import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { addJobs } from "@/lib/queue";
import { topicsSchema } from "@/lib/zod";

export async function POST(req: NextRequest) {
  try {
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const res = topicsSchema.safeParse(body);

    if (!res.success) {
      console.error(res.error);
      return NextResponse.json({ error: "Invalid input" }, { status: 400 });
    }

    const easyTopics = res.data.topics.filter(
      (topic) => topic.weightage === "low"
    );
    const mediumTopics = res.data.topics.filter(
      (topic) => topic.weightage === "medium"
    );
    const hardTopics = res.data.topics.filter(
      (topic) => topic.weightage === "high"
    );

    if (!easyTopics.length && !mediumTopics.length && !hardTopics.length) {
      return NextResponse.json(
        { error: "No topics selected", credits: 0 },
        { status: 400 }
      );
    }

    const reqCredits =
      easyTopics.length * 4 + mediumTopics.length * 7 + hardTopics.length * 10;

    const user = await prisma.user.findFirst({
      where: { id: session.user.id },
    });

    if (user?.credits! - user?.reservedCredits! < reqCredits) {
      return NextResponse.json(
        {
          error: "Insufficient credits. Try deleting some topics.",
          credits: Math.round(reqCredits),
        },
        { status: 400 }
      );
    }

    await prisma.user.update({
      where: { id: session.user.id },
      data: { reservedCredits: reqCredits },
    });

    const newMaterial = await prisma.material.create({
      data: {
        title: res.data.moduleName,
        description: "A study material generated by AI",
        userId: session.user.id!,
        course: res.data.course || "",
        exam: res.data.exam || "",
        language: res.data.language || "english",
        complexity: res.data.complexity,
        type: res.data.type,
        subject: res.data.subject,
        totalParts: res.data.topics.length,
      },
    });

    const enqueueStatus = await addJobs(res.data, newMaterial.id);
    if (!enqueueStatus) {
      await prisma.material.delete({ where: { id: newMaterial.id } });
      throw new Error("Failed to enqueue jobs");
    }

    return NextResponse.json({
      message: "Success",
      materialId: newMaterial.id,
    });
  } catch (err) {
    console.error(err);
    return NextResponse.json(
      { error: "Some error occured. Please try again later." },
      { status: 500 }
    );
  }
}
